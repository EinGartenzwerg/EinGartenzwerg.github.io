# Local IspellDict: en
#+STARTUP: showeverything
#+SPDX-FileCopyrightText: 2020 Maximilian Harl
#+SPDX-License-Identifier: CC-BY-SA-4.0

#+OPTIONS: toc:1

#+TITLE: Overview of Introduction to Computer Science
#+KEYWORDS: computer science

* Introduction

** Usage hints
  #+REVEAL_HTML: <script data-quiz="quizUsageHints" src="./quizzes/usage-hints.js"></script>

** Learning Objectives
   :PROPERTIES:
   :CUSTOM_ID: learning-objectives-os
   :reveal_extra_attr: data-audio-src="https://oer.gitlab.io/audio/learning-objectives.ogg"
   :END:
   - Explain notion of Operating System and its goals
     - Explain notion of kernel with system call API
       - (More details in [[file:Operating-Systems-Interrupts.org][next presentation]])
   - Explain notions and relationships of process, thread, multitasking
#+INCLUDE: "~/.emacs.d/oer-reveal-org/learning-objectives-notes.org"

** Recall: Big Picture of CSOS
   - Computer Structures and Operating Systems (CSOS)
     #+ATTR_REVEAL: :frag (gray-out appear)
     - CS: How to build a computer from logic gates?
       {{{reveallicense("./figures/gates/nand.meta","6vh")}}}
       - Von Neumann architecture
       - CPU (ALU), RAM, I/O
	 {{{reveallicense("./figures/devices/cpu.meta","12vh")}}}
     - OS: What *abstractions* do Operating Systems provide for
       applications?
       - Processes and threads with scheduling and concurrency, virtual memory
         {{{reveallicense("./figures/screenshots/pong.meta","25vh")}}}
       - What is currently executing why and where, using what
         resources how?

*** OS Responsibilities
    {{{revealimg("./figures/external-non-free/jvns.ca/OS-responsibilities.meta",t,"50vh")}}}

* Operating Systems
** Sample Modern Operating Systems
   :PROPERTIES:
   :CUSTOM_ID: modern-oss
   :reveal_extra_attr: data-audio-src="./audio/1-Sample-OSs.ogg"
   :END:
   #+INDEX: Operating system!Examples (Introduction)
   - Different systems for different scenarios
     - Mainframes
       - [[https://en.wikipedia.org/wiki/BS2000][BS2000/OSD]],
         [[https://en.wikipedia.org/wiki/General_Comprehensive_Operating_System][GCOS]],
         [[https://en.wikipedia.org/wiki/Z/OS][z/OS]]
     - PCs
       - GNU/Linux, MacOS, [[https://www.redox-os.org][Redox]], Windows
     - Mobile devices
       - Variants of other OSs
       - Separate developments, e.g.,
         BlackBerry
         ([[https://en.wikipedia.org/wiki/BlackBerry_10][BlackBerry 10]]
         based on QNX, abandoned),
	 [[https://en.wikipedia.org/wiki/Google_Fuchsia][Google Fuchsia]],
         [[https://en.wikipedia.org/wiki/Symbian][Symbian]] (Nokia, most popular smartphone OS until
         2010, now replaced)
     - Gaming devices
     - Real-time OS
       - Embedded systems
       - [[#L4][L4]] variants, [[https://en.wikipedia.org/wiki/QNX][QNX]],
         [[https://en.wikipedia.org/wiki/VxWorks][VxWorks]]
#+BEGIN_NOTES
There is a vast variety of OSs for different devices and usage
scenarios, of which this slide shows a selection.

The goal of the OS sessions is not to turn you into an expert for any
specific OS, but to teach you major concepts and techniques that are shared by
most modern OSs.  As [[file:Operating-Systems-Motivation.org][explained previously]]
my hope is that you can apply your knowledge on the one hand when
designing, analyzing, or implementing information systems and on the
other when taking control of your own devices.

Based on my personal beliefs, I will not teach you anything about
non-free OSs (except maybe first steps to get away from them).  In
particular, examples shown in presentations and in class will be based
on the [[file:Operating-Systems-Motivation.org::#free-software][free]] OS
[[file:Operating-Systems-Motivation.org::#gnu-linux][GNU/Linux]].  As GNU/Linux is
free, you can experiment with it at any level of detail yourself.
#+END_NOTES

** Definition of Operating System
   :PROPERTIES:
   :CUSTOM_ID: os-definition
   :END:
   #+INDEX: Operating system!Definition (Introduction)
   - Definition from cite:Hai19: *Software*
     - that *uses hardware* resources of a computer system
     - to provide support for the *execution of other software*.

   {{{reveallicense("./figures/OS/hail_f0101.pdf.meta","35vh")}}}

*** Aside: API
    :PROPERTIES:
    :CUSTOM_ID: API
    :END:
    - API = [[https://en.wikipedia.org/wiki/Application_programming_interface][Application Programming Interface]]
      - Set of functions or interfaces or protocols defining how to
        use some system (as programmer)
      - E.g.,
        [[https://docs.oracle.com/en/java/javase/14/docs/api/index.html][Java 14 API ]]
        - Packages with classes, interfaces, methods, etc.

*** OS Services
    - OS services/features/functionality defined by its API
      - Functionality includes
      #+ATTR_REVEAL: :frag (appear)
      - Support for *multiple concurrent* computations
	- Run programs, divide hardware, manage state
      - *Control interactions* between concurrent computations
	- E.g., locking, private memory
      - Typically, also *networking* support

    {{{reveallicense("./figures/OS/hail_f0101.pdf.meta","25vh")}}}

** OS, Kernel, User Interface
   :PROPERTIES:
   :CUSTOM_ID: os-boundary
   :END:
   #+ATTR_REVEAL: :frag (appear)
   - Boundary between OS and applications is fuzzy
   - *Kernel* is fundamental, core part of OS
     - Kernel defines API and services via *system call* interface
     - (More details on next and [[#kernel][later slide]])
   - User interface (UI)
     - GUI = process(es) using kernel functionality to handle (touch,
       keyboard, mouse) input, start programs, display output, ...
       - Explorer for Windows
       - Various desktop environments for GNU/Linux
     - Command line = process using kernel functionality to handle
       (keyboard) input, start programs, display text output, ...
     - Note: OSs for embedded systems may not have UI at all

*** How to Talk to OSs
    {{{revealimg("./figures/external-non-free/jvns.ca/system-calls.meta",t,"50vh")}}}

*** User Space and Kernel Space
    {{{revealimg("./figures/external-non-free/jvns.ca/user-space.meta",t,"50vh")}}}

*** OS Size
    - From cite:TB15
      - Size of source code of the heart Windows or GNU/Linux is about
	*5 million lines of code*
	- Think of book with 50 lines per page, 1000 pages
	- Need 100 books or an entire bookcase
      - Windows with essential shared libraries is about *70 million lines
	of code*
	- 10 to 20 bookcases
    - How to *understand* or maintain that?
       - → Abstraction, layering, modularization

** OS Architecture and Kernel Variants
   :PROPERTIES:
   :CUSTOM_ID: kernel-variants
   :reveal_extra_attr: data-audio-src="./audio/1-Kernel-variants.ogg"
   :END:
   #+INDEX: Kernel!Variants (Introduction)
   #+INDEX: Kernel!Monolithic (Introduction)
   #+INDEX: Kernel!Micro (Introduction)
   #+INDEX: Privilege level (Introduction)
   #+INDEX: Kernel mode (Introduction)
   #+INDEX: User mode (Introduction)
   {{{revealimg("./figures/OS/1280px-OS-structure2.svg.meta",t,"35vh")}}}

   See [[http://www.makelinux.net/kernel_map/][this map of the Linux kernel]]
   for a real-life monolithic example
#+BEGIN_NOTES
This figure shows different approaches towards layering and modularization
in the context of OS kernels.  First of all, note the common layers,
namely applications at the top and hardware at the bottom.

In between are different layers related to what we think of as OS
functionality.  Note that this OS functionality is marked with a red
(left) and yellow (middle and right) background labeled “kernel mode”
and “user mode”, respectively.  These modes refer to different
CPU privilege levels, which will be discussed in the
[[file:Operating-Systems-Interrupts.org::#kernel-mode][next presentation]];
for now it is sufficient to know that code running in kernel mode has
full control over the underlying hardware, while code running in user
mode is restricted and needs to invoke lower layers (that run in kernel
mode) for certain functionality.

At one extreme, shown in the middle here, are so-called /micro kernels/,
which just provide the minimal functionality and services as
foundation for full-fledged OSs.  Typical functionality that we expect
from OSs, such as file services or hardware independent network
access, is then /not/ implemented in the kernel but in user mode
processes or servers.  The [[#L4][L4 family mentioned later on]] as
well as [[#modern-oss][Fuchsia]] provide examples for micro kernels.

The other extreme is made up of so-called /monolithic kernels/, which
provide (almost) everything that we expect from OSs.  For
modularization, such kernels may be structured in a sequence of
layers, where the top layer provides the system call API to be
explained on subsequent slides, while the bottom layer implements
device driver abstractions to hide hardware peculiarities.
Intermediate layers offer levels of abstraction on the way from
hardware to application facing functionality.  GNU/Linux and Windows
come with monolithic kernels.

Finally, /hybrid kernels/ can be built as trade-off between both
extreme approaches.
#+END_NOTES

*** OS Kernel
    :PROPERTIES:
    :CUSTOM_ID: kernel
    :END:
    #+INDEX: Kernel!Explanation (Introduction)
    - OS runs as code on CPU
      - Just as any other program
    - *Kernel* contains central part of OS
      #+ATTR_REVEAL: :frag (appear)
      - Provides *API* for OS services via [[#system-calls][system calls (next slide)]]
      - Code and data of kernel typically main memory resident
      - Kernel functionality runs in kernel mode of CPU, reacts to
        system calls and interrupts
	- Details in [[file:Operating-Systems-Interrupts.org][next presentation]]
      - Variants ([[#kernel-variants][previous slide]])
	- Monolithic (“large,” all OS related services)
	- Micro kernel (“small,” only necessary services)
	- “Best” design subject to research
	  - Provable security only with micro kernels ([[#L4][seL4]])

*** System Calls
    :PROPERTIES:
    :CUSTOM_ID: system-calls
    :END:
    #+INDEX: System call!Definition (Introduction)
    - System call = function = part of kernel API
      - Implementation of OS service
	- E.g., process execution, main memory allocation,
          hardware resource access (e.g., keyboard, network, disk, graphics
          card)
    - Different OSs offer different system calls (i.e., offer
      incompatible APIs)
      - With different implementations
      - With different calling conventions

*** Sample Microkernel: L4
    :PROPERTIES:
    :CUSTOM_ID: L4
    :END:
    #+INDEX: L4 (Introduction)
    #+INDEX: Kernel!Micro!L4 (Introduction)
    - L4, developed by Jochen Liedtke, late 1990s
      - Liedtke's 4th system (after Algol interpreter, Eumel, and L3)
      - Now with [[http://l4hq.org/projects/kernel/][family of L4 based kernels]]
      - Notable properties
	- *12 KB* source code
	- *7* system calls
	- Abstractions: Address space, Threads,
           Inter-Process-Communication (IPC)
    - Breakthrough result in 2009, cite:KEH+09: *Formal verification*
      of the OS kernel [[https://sel4.systems/][seL4]]
      - Mathematical *proof* of correctness
	- Updates/patches are a *thing of the past*
      - More recent description in cite:KAE+14

#+REVEAL: split
    - L4 variants today
      - OKL4, deployed in
        [[https://gdmissionsystems.com/products/cross-domain-solutions/hypervisor#3][over 2 billion devices]]
        - OS for baseband processor (modem, management of radio functions)
	  - Starting with Qualcomm
	- Embedded, mobile, IoT, automotive, defense, medical, industrial,
	  and enterprise applications
      - Another variant in Apple's Secure Enclave coprocessor (see
        [[https://support.apple.com/guide/security/welcome/web][PDF on this page]])
	- A7 processor (iPhone 5S, iPad mini 3) and later
      - Airbus 350, Merkelphone

* Multitasking

** Multitasking
   :PROPERTIES:
   :CUSTOM_ID: multitasking
   :END:
   #+INDEX: Multitasking (Introduction)
   #+INDEX: Scheduling (Introduction)
   #+ATTR_REVEAL: :frag (appear)
   - Fundamental OS service: *Multitasking*
     - Manage *multiple computations* going on *at the same time*
     - E.g., surf on Web while Java project is built and music plays
   - OS supports multitasking via *scheduling*
     - Decide what computation to execute when on what CPU core
     - Frequently per second, beyond human perception
   - Multitasking introduces *concurrency*
     - (Details and challenges in upcoming sessions)
     - Even with single CPU core, illusion of “simultaneous” or
       “parallel” computations
       - (Later presentation: Advantages include
         [[file:Operating-Systems-Threads.org::#thread-reasons][improved responsiveness and improved resource usage]])

** Computations
   :PROPERTIES:
   :CUSTOM_ID: computations-processes-threads
   :END:
   #+INDEX: Process!Initial explanation (Introduction)
   #+INDEX: Thread!Initial explanation (Introduction)
   - Various technical terms for “computations”: Jobs, tasks, processes,
     threads, …
     #+ATTR_REVEAL: :frag (appear)
     - We use only *thread* and *process*
     - *Process*
       - Container for related threads and their resources
       - Created upon start of program and by programs (child processes)
       - Unit of management and protection (threads from different
         processes are isolated from another)
     - *Thread*
       - Unit of scheduling and concurrency
       - Sequence of instructions (to be executed on CPU core)
       - Single process may contain just one or several threads, e.g.:
	 - Online game: different threads with different code for game
           AI, GUI events, network handling
	 - Web server handling requests from different clients in
           different threads sharing same code

*** Threads!
    :PROPERTIES:
    :CUSTOM_ID: drawing-threads
    :END:
    #+INDEX: Thread!Drawing (Introduction)
    {{{revealimg("./figures/external-non-free/jvns.ca/threads.meta",t,"50vh")}}}

*** Process Aspects (1/3)
    :PROPERTIES:
    :CUSTOM_ID: drawing-process
    :END:
    #+INDEX: Process!Drawing (Introduction)
    {{{revealimg("./figures/external-non-free/jvns.ca/process.meta",t,"50vh")}}}

*** Process Aspects (2/3)
    :PROPERTIES:
    :CUSTOM_ID: process-definition
    :END:
    #+INDEX: Process!Definition (Introduction)
    - Approximately, process ≈ *running program*
      - E.g., text editor, game, audio player
      - OS manages lots of them simultaneously
    - Really, process = “whatever your OS manages as such”
      - OS specific tools to inspect processes (research on your own!)

*** Process Aspects (3/3)
    :PROPERTIES:
    :CUSTOM_ID: process-examples
    :END:
    #+INDEX: Process!Examples (Introduction)
    - Single program may create *multiple* processes, e.g.:
      - Apache Web server with “process per request”
	([[https://httpd.apache.org/docs/2.4/mod/prefork.html][MPM prefork]])
      - Web browsers with “process per tab” or separation of UI and
        web content, e.g.,
	[[https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiprocess_Firefox][Multiprocess Firefox]]
    - Many-to-many relationship between “applications” and processes
      - E.g., [[https://www.gnu.org/software/emacs/][GNU Emacs]]
	provides lots of “applications”
	- Core process includes: Text editor,
          chat/mail/news/RSS clients, Web browser, calendar
	- On-demand child processes: Spell checker, compilers, PDF viewer

** Processes vs Threads
   :PROPERTIES:
   :CUSTOM_ID: thread-quadrants
   :reveal_extra_attr: data-audio-src="./audio/1-Processes-vs-Threads.ogg"
   :END:
   #+INDEX: Process!Execution environments (Introduction)
   {{{revealimg("./figures/OS/processes-vs-threads.meta",t,"40vh",nil,none)}}}

#+BEGIN_NOTES
This figure shows a classification of platforms or execution
environments for processes and threads from cite:ABL+97.  Note that
although all threads are represented using the same curved line for
graphical simplicity, each thread shown in the figure can actually
execute its own instructions, independently from all other threads.
Furthermore, although multiple threads are shown in parallel, /no/
assumptions are made whether their instructions are really /executed/
in parallel; clearly, parallel execution requires hardware support,
e.g., in the form of multiple CPU cores, as well as OS support.

As shown in quadrant Q2, a platform may be characterized as supporting
just a single process with a single thread, which effectively means
that it has no notion of process or thread at all but just happily
executes whatever instructions are there in one undifferentiated
context.  Thus, multitasking is /not/ supported.
Actually, the CS part of CSOS introduced one such platform …

Q1 indicates multiple threads executing inside a single process, which
may appear strange at first sight, but you actually also know one such
execution environment quite well.  You should not think about platforms
consisting of hardware with OS here but about execution environments
that can be started inside OSs …

Q3 captures platforms with multiple single-threaded processes.  Again,
if everything is single-threaded, then the platform actually does not
support threads, but just schedules processes for execution.  This is
mostly the case for older OSs.

Finally, Q4 contains multiple processes which in turn can host
multiple threads.  This is what we take for granted in upcoming
OS sessions.
#+END_NOTES

** Exercises
   :PROPERTIES:
   :CUSTOM_ID: jitt
   :reveal_data_state: jitt no-toc-progress
   :END:
   Work through the following tasks.  Submit solutions in {{{jittquiz}}}.

*** Bash Command Line
    :PROPERTIES:
    :CUSTOM_ID: ticket-1
    :reveal_data_state: jitt no-toc-progress
    :END:
    - Solve [[https://github.com/veltman/clmystery][The Command Line Murders]]
      - Game, which teaches use of the Bash command line
      - Command line = shell = text-mode user interface for OS
        - Create processes for programs or scripts
      - Different shells come with incompatible features
        - Game supposes Bash in combination with typical GNU/Unix tools (e.g.,
          ~grep~, ~head~, ~tail~)
        - [[#bash-access][See next slide for some options]]
    - Task
      - Access files for game
        - [[https://github.com/veltman/clmystery/archive/master.zip][Download]]
          or clone with ~git clone https://github.com/veltman/clmystery.git~
      - Play game according to
        [[https://github.com/veltman/clmystery/blob/master/README.md][its README]]
        - [[#bash-access][See next slide for hints]]
      - While solving the case, you may want to see line no. 179 of some
        (large) text file
      - *Submit* commands to view line 179 of some text file, using
        ~head~ and ~tail~, with short explanation
    - (Command line examples show up throughout this course; details
      of file handling to be revisited in
      [[file:Operating-Systems-Processes.org][presentation on processes]])

*** Using Bash as Command Line
    :PROPERTIES:
    :UNNUMBERED: t
    :CUSTOM_ID: bash-access
    :reveal_data_state: jitt no-toc-progress
    :END:
    - Where/how to start Bash as command line
      - Built-in with GNU/Linux; use own (virtual) machine
      - Alternatively, students reported success with
        [[https://docs.microsoft.com/en-us/windows/wsl/about][Windows Subsystem for Linux/Ubuntu on Windows]]
      - Alternatives without Linux kernel (no ~/proc~ for later tasks)
        - Use cygwin according to hints in
          [[https://github.com/veltman/clmystery/blob/master/cheatsheet.md][game’s cheatsheet]]
        - Shell coming with [[https://gitforwindows.org/][Git for Windows]]
        - [[https://en.wikipedia.org/wiki/Terminal_(macOS)][Terminal of macOS]]
    - Basic hints for [[https://github.com/veltman/clmystery][The Command Line Murders]]
      - [[https://github.com/veltman/clmystery/blob/master/cheatsheet.md][Game’s cheatsheet]]
        is misnamed; it contains essential information to get you started
      - Once on command line, maybe try this first:
        - ~ls~ (short for “list”) to view contents of current directory
        - ~pwd~ (short for “print working directory”) to print name of
          current directory
        - ~cd replace-this-with-name-of-directory-of-mystery~ (short
          for “change directory”) to change directory to chosen
          location, e.g., location of mystery’s files
        - ~man name-of-command~ shows manual page for ~name-of-command~
          - Try ~man man~ first, then ~man ls~
      - Afterwards, follow
        [[https://github.com/veltman/clmystery/blob/master/README.md][game’s README]]
        - (Which supposes that you changed to the directory with the
          game’s files already)

*** Processes and threads
    :PROPERTIES:
    :reveal_data_state: jitt no-toc-progress
    :END:
    Sort sample OSs into the [[#thread-quadrants][quadrants of Anderson et al.]]
    - Hack, MS-DOS, Java Virtual Machine, Windows 10, GNU/Linux, GNU/Linux
      prior kernel 1.3.56, GNU/Linux starting with kernel 1.3.56
      - GNU/Linux kernel 1.3.56 dates back to 1996
      - Use educated guessing there ;)

*** BattleThreads
    :PROPERTIES:
    :CUSTOM_ID: battlethreads
    :END:
    TODO

*** Feedback
    - {{{understandingquestion}}}

* Conclusions
** Summary
   - OS is Software
     - that *uses hardware* resources of a computer system
     - to provide support for the *execution of other software*.
       - Computations are performed by threads.
       - Threads are grouped into processes.
   - OS kernel
     - provides interface for applications and
     - manages resources.

#+INCLUDE: "backmatter.org"
